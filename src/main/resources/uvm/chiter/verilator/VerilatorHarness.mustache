#include "{{dutVerilatorClassName}}.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include <iostream>

#define TOP_CLASS {{dutVerilatorClassName}}
#define VERILATED_C VerilatedVcdC

void vl_finish(const char* filename, int linenum, const char* hier) {
  Verilated::runFlushCallbacks();
  encounteredFinish = true;
}

static bool encounteredFatal = false;
void vl_fatal(const char* filename, int linenum, const char* hier, const char* msg) {
  std::cerr << "fatal! (" << filename << ", " << linenum << ", " << hier << ", " << msg << ")" << std::endl;
  Verilated::runFlushCallbacks();
  encounteredFatal = true;
}

static bool encounteredStop = false;
void vl_stop(const char* filename, int linenum, const char* hier) {
  Verilated::runFlushCallbacks();
  encounteredStop = true;
}

double sc_time_stamp() { return 0; }

struct sim_state {
    TOP_CLASS* dut;
    VERILATED_C* tfp;
    VerilatedContext* contextp;

    sim_state():
        dut(new TOP_CLASS),
        tfp(nullptr),
        contextp(new VerilatedContext)
    {
    }

    inline int64_t step(int32_t cycles) {
        for (int32_t i = 0; i < cycles; i++) {
            contextp->timeInc(1);
            dut->eval();
            tfp->dump(contextp->time());
            if (encounteredStop) {
                encounteredStop = false;
                encounteredFinish = false;
                return (2 << 32) | ((int64_t)(i + 1));
            } else if (encounteredFinish) {
                encounteredFinish = false;
                return (1 << 32) | ((int64_t)(i + 1));
            } else if (encounteredFatal) {
                encounteredFatal = false;
                return (3 << 32) | ((int64_t)(i + 1));
            }
        }
        return (int64_t)cycles;
    }


}